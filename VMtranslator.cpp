#include <iostream>
#include <filesystem>
#include <vector>
#include <sstream>
#include <algorithm>
#include "Parser.h"
#include "Code.h"
namespace fs = std::filesystem;

// VM Translator
//
// This program takes the VM code generated by the Jack compiler and translates it into Hack assembly.
// As such, this translator serves as the back-end of the compiler.
// Jack, the intermediate VM code, and Hack are all defined in the architecture course nand2tetris.
//


// VMtranslator may only have a single argument passed to it from the terminal
constexpr int programMaxPassedArgCount{ 2 };

//Check that the proper quantity of arguments is passed in when calling the program
bool verifyProgramInput(const int argc)
{
	//Since program name counts as an argument, increment argCount by 1 to ignore that value
	if ((argc > programMaxPassedArgCount + 1) || argc == 1) { return false; }
	
	return true;
}

//Check if the passed argument is a single VM file or a directory
ArgumentType checkForVMFileOrDirectory(const std::string passedName)
{
	if(passedName.find(".") != std::string::npos) { return ArgumentType::vmFile; }
	else { return ArgumentType::directory; }
}

//Clips off file .vm extensions
std::string snipVMExtension(std::string fileName)
{
	if (fileName.find(".vm") != std::string::npos)
	{
		fileName.erase(fileName.length() - 3);
	}

	return fileName;
}

//If passed a directory, extract folder name and use it for the assembly name
std::string extractFileNameFromDirectory(std::string name)
{
	size_t positionOfLastSlash;

	if (name[name.length() - 1] == '\\')
	{
		name.pop_back();
	}

	positionOfLastSlash = name.rfind("\\");

	return name.substr(positionOfLastSlash + 1);	
}

//Removes quotes from directory name if they are present
std::vector<std::string> removeQuotesFromName(std::vector<std::string>& names)
{
	try
	{
		for (std::string& name : names)
		{
			name.erase(0, 1);
			name.erase(name.length() - 1, 1);
		}
	}
	catch (std::out_of_range)
	{
		std::cerr << "ERROR:  Attempted to erase substring that is longer than the string.\n";
		throw;
	}

	return names;
}

//Retrieves all file names
std::vector<std::string> getFileNamesInDirectory(std::string& path)
{
	std::vector<std::string> names;

	for (const auto& entry : std::filesystem::directory_iterator(path))
	{
		std::stringstream ss = std::stringstream();
		ss << entry.path().filename();
		std::string name = ss.str();
		names.push_back(name);
	}
	
	return names;
}

//Removes files with non-.VM extensions
std::vector<std::string> removeNonVMFiles(std::vector<std::string>& names)
{
	//remove_if moves all files ending with .vm to front of container returning an iterator pointing one value past the last instance of .vm
	auto it{ std::remove_if(names.begin(), names.end(),
		[](std::string name)
		{
			return(name.find(".vm") == std::string::npos);
		}) };

	//When this iterator is passed into erase, it erases all the non-.VM strings from the container
	try
	{
		names.erase(it, names.end());
	}
	catch (std::out_of_range)
	{
		std::cerr << "ERROR:  Attempted to erase substring that is longer than the string.\n";
		throw;
	}

	return names;
}

//Get list of .VM files to translate
std::vector<std::string> buildListOfFiles(const std::string fileOrDirName, const ArgumentType argType)
{
	std::string outputName;
	std::vector<std::string> names;

	if (argType == ArgumentType::directory)
	{
		std::string path = fileOrDirName;
		names = getFileNamesInDirectory(path);
		names = removeNonVMFiles(names);
		names = removeQuotesFromName(names);
		return names;
	}
	else
	{
		names.push_back(fileOrDirName);
		return names;
	}
}

//Open a single output file regardless of if there are multiple .vm files
void openOutputFile(std::ofstream& outFile, const ArgumentType argType, std::string fileOrDirName)
{
	std::string nameASM;

	if (argType == ArgumentType::vmFile)
	{
		nameASM = snipVMExtension(fileOrDirName);
		nameASM.insert(nameASM.length(), ".asm");
	}
	else
	{
		nameASM = extractFileNameFromDirectory(fileOrDirName);
		nameASM.insert(nameASM.length(), ".asm");
		if (fileOrDirName[fileOrDirName.length() - 1] == '\\')
		{
			nameASM = fileOrDirName.insert(fileOrDirName.length(), nameASM);
		}
		else
		{
			fileOrDirName.insert(fileOrDirName.length(), "\\");
			nameASM = fileOrDirName.insert(fileOrDirName.length(), nameASM);
		}
	}

	outFile.open(nameASM);

	if (!outFile.is_open())
	{
		std::cerr << "ERROR:  Couldn't open write file.\n";
		throw Errors::errorOpeningWriteFile;
	}
}

//Open a VM file to read from
void openInputFile(const std::string name, ArgumentType argType, std::ifstream& inFile, std::string fileOrDirName)
{
	std::string openName{ name };

	try
	{
		if (argType == ArgumentType::vmFile)
		{
			inFile.open(openName);
		}
		else
		{
			if (fileOrDirName[fileOrDirName.length() - 1] == '\\')
			{
				openName = fileOrDirName + name;
				inFile.open(openName);
			}
			else
			{
				fileOrDirName.push_back('\\');
				openName = fileOrDirName + name;
				inFile.open(openName);
			}
		}
	}
	catch (std::ios_base::failure)
	{
		std::cerr << "Error:  Could not open input file " << openName << "\n";
	}
}

//Translates all VM files into a single assembly file
void translateVMFiles(std::ifstream& inputFile, std::ofstream& outputFile, const std::string fileOrDirName, const std::string bootStrapArg)
{
	ArgumentType argType{ checkForVMFileOrDirectory(fileOrDirName) };

	std::vector<std::string> names{ buildListOfFiles(fileOrDirName, argType) };
	
	openOutputFile(outputFile, argType, fileOrDirName);

	Code code(outputFile, bootStrapArg);

	for (std::string vmFile : names)
	{
		openInputFile(vmFile, argType, inputFile, fileOrDirName);
		Parser parse(inputFile);
		code.setFileName(vmFile);

		while (parse.hasMoreCommands())
		{		
			parse.advance();
			code.writeCommandToFile(parse.commandType(), parse.getArg1(), parse.getArg2());
		}

		inputFile.close();
	}

	outputFile.close();
}


int main(int argc, char* argv[])
{
	std::ifstream inputFile;
	std::ofstream outputFile;
	std::string fileOrDirName;
	std::string bootStrapArg;

	if (argc >= 2) { fileOrDirName = argv[1]; }
	if (argc == 3) { bootStrapArg = argv[2]; }

	if(!verifyProgramInput(argc))
	{	
		std::cerr << "Improper arguments. Please pass arguments to the VM translator as shown\n\n";
		std::cerr << "<Name of single .VM file with extension OR Director holding multiple .VM files> <-n>\n";
		std::cerr << "<-n> is optional and will disable bootstrap code from appearing in final assembly file.\n\n";
		std::cerr << "Ex: >VMtranslator.exe SimpleFunction.vm -n Or >Vmtranslator.exe C:\\User\\VMFoler\n\n";
		std::cerr << "Please pass in the name of a single .VM file or the absolute directory of multiple .VM files" << "\n";
		return -1;
	}

	try
	{
		translateVMFiles(inputFile, outputFile, fileOrDirName, bootStrapArg);
	}
	catch (...)
	{
		std::cerr << "Exiting.\n";
	}
}
